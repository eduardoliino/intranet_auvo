{% extends 'base.html' %} {% block content %}
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='css/newsletter.css') }}"
/>

<div class="nl-feed py-4" x-data="newsletterFeed()">
  <h1 class="mb-4">Newsletter</h1>

  {% if fixados_posts or fixados_enquetes %}
  <h4 class="mb-3 text-muted">Destaques</h4>
  <div class="row g-5 mb-5">
    {% for post in fixados_posts %}
    <div class="col-md-6">{% include 'partials/news_post_card.html' %}</div>
    {% endfor %} {% for enquete in fixados_enquetes %}
    <div class="col-md-6">{% include 'partials/news_enquete_card.html' %}</div>
    {% endfor %}
  </div>
  {% endif %}

  <h4 class="mb-3 text-muted">Feed</h4>
  <div class="row g-5">
    {% for post in feed_posts %}
    <div class="col-md-6">{% include 'partials/news_post_card.html' %}</div>
    {% endfor %} {% for enquete in feed_enquetes %}
    <div class="col-md-6">{% include 'partials/news_enquete_card.html' %}</div>
    {% endfor %} {% if not feed_posts and not feed_enquetes %}
    <p class="text-center text-muted">Nenhuma publicação no feed.</p>
    {% endif %}
  </div>

  <div
    x-show="isModalOpen"
    x-transition:enter="transition ease-out duration-200"
    x-transition:enter-start="opacity-0"
    x-transition:enter-end="opacity-100"
    x-transition:leave="transition ease-in duration-150"
    x-transition:leave-start="opacity-100"
    x-transition:leave-end="opacity-0"
    class="nl-modal-overlay"
    @click.self="closeModal()"
    @keydown.escape.window="closeModal()"
    x-cloak
  >
    <div
      x-show="isModalOpen"
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 scale-95"
      x-transition:enter-end="opacity-100 scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 scale-100"
      x-transition:leave-end="opacity-0 scale-95"
      class="nl-modal-dialog"
      role="dialog"
      aria-modal="true"
      :aria-labelledby="'modal-title-' + modalContent.postId"
    >
      <header class="nl-modal-header">
        <h5
          class="nl-modal-title"
          x-text="modalContent.postTitle || 'Detalhes'"
        ></h5>
        <div class="nl-modal-actions">
          <!-- aparece se encontrarmos um link de origem no conteúdo -->
          <a
            x-show="sourceLink"
            :href="sourceLink"
            target="_blank"
            rel="noopener"
            class="nl-link-out"
            >Abrir link</a
          >
          <button
            x-show="sourceLink"
            type="button"
            class="nl-btn-icon"
            @click="copySourceLink()"
            aria-label="Copiar link"
          >
            <i class="bi bi-link-45deg" aria-hidden="true"></i>
          </button>
          <button
            type="button"
            class="nl-btn-icon"
            @click="closeModal"
            aria-label="Fechar"
          >
            <i class="bi bi-x-lg" aria-hidden="true"></i>
          </button>
        </div>

        <!-- progresso de leitura -->
        <div class="nl-progress">
          <span :style="{ width: scrollPct + '%' }"></span>
        </div>
      </header>

      <div
        class="nl-modal-body nl-scrollfade custom-scrollbar"
        x-ref="modalBody"
        :class="{'has-top-shadow': !atTop, 'has-bottom-shadow': !atBottom}"
        @scroll.debounce.100ms="onBodyScroll($event)"
        :aria-busy="isLoading"
      >
        <div
          x-show="isLoading"
          :class="'embed-placeholder ' + (placeholderClass || 'aspect-video')"
        ></div>

        <!-- Container para todo o conteúdo que aparece após o carregamento -->
        <div x-show="!isLoading" class="w-100">
          <div
            x-ref="embedContent"
            class="nl-embed-wrap"
            x-html="modalContent.post_html"
          ></div>

          <hr class="my-4" />

          <div class="d-flex align-items-center gap-2 flex-wrap mb-3">
            <template
              x-for="reactionType in reactionTypes"
              :key="reactionType.type"
            >
              <button
                :class="['nl-reaction-chip', { 'selected': modalContent.reactions.user_reaction === reactionType.type, 'zero-count': !(modalContent.reactions.counts[reactionType.type] > 0) }]"
                @click="toggleReaction(reactionType.type)"
              >
                <i class="bi" :class="reactionType.icon"></i>
                <span
                  class="nl-count"
                  x-text="modalContent.reactions.counts[reactionType.type] || 0"
                ></span>
              </button>
            </template>
          </div>

          <h6>Comentários</h6>
          <div class="mb-4">
            <template
              x-for="comment in modalContent.comments"
              :key="comment.id"
            >
              <div class="d-flex align-items-start my-3">
                <template x-if="comment.user_photo">
                  <img
                    :src="comment.user_photo"
                    class="nl-avatar me-3"
                    :alt="'Foto de ' + comment.user_name"
                  />
                </template>
                <template x-if="!comment.user_photo">
                  <div
                    class="nl-avatar d-flex justify-content-center align-items-center bg-secondary text-white me-3 flex-shrink-0"
                  >
                    <span x-text="comment.user_initials"></span>
                  </div>
                </template>
                <div class="w-100">
                  <strong x-text="comment.user_name"></strong>
                  <p
                    class="mb-0"
                    style="white-space: pre-wrap; word-break: break-word"
                    x-text="comment.text"
                  ></p>
                </div>
              </div>
            </template>
          </div>
        </div>
      </div>

      <footer class="nl-modal-footer">
        <form class="nl-comment-bar" @submit.prevent="submitComment()">
          <div class="nl-comment-field">
            <!-- Botão Emoji -->
            <button
              type="button"
              class="nl-emoji-btn"
              @click="showEmojiPicker = !showEmojiPicker; if(showEmojiPicker){ $nextTick(()=> customizeEmojiPicker()) }"
              :aria-expanded="showEmojiPicker ? 'true' : 'false'"
              aria-label="Inserir emoji"
            >
              <i class="bi bi-emoji-smile"></i>
            </button>

            <textarea
              x-model="newCommentText"
              x-ref="commentInput"
              rows="1"
              class="nl-comment-input"
              placeholder="Adicionar um comentário..."
              @keydown.enter.prevent.stop="handleCommentSubmit($event)"  <!-- Enter envia / Shift+Enter quebra linha -->
              @input="autosizeTextarea($event.target)"
              aria-label="Adicionar um comentário"
            ></textarea>

            <button
              type="submit"
              class="nl-comment-send"
              :disabled="isSubmitting || !newCommentText.trim()"
              aria-label="Enviar comentário"
            >
              <i class="bi bi-send-fill" aria-hidden="true"></i>
            </button>

            <!-- Popover do Emoji Picker -->
            <div
              class="nl-emoji-popover"
              x-show="showEmojiPicker"
              x-transition
              @click.outside="showEmojiPicker=false"
              x-init="$nextTick(()=> customizeEmojiPicker())"
            >
              <emoji-picker
                x-ref="emojiPicker"
                @emoji-click="onEmojiClick"
              ></emoji-picker>
            </div>
          </div>
        </form>
      </footer>
    </div>
  </div>
</div>
{% endblock %}

{% block page_scripts %}
<!-- Emoji Picker (Web Component) -->
<script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
  function newsletterFeed() {
    return {
      // STATE
      isModalOpen: false,
      isLoading: true,
      newCommentText: "",
      isSubmitting: false,
      sourceLink: "",
      scrollPct: 0,
      atTop: true,
      atBottom: false,
      placeholderClass: "aspect-video",
      showEmojiPicker: false,
      emojiPickerStyled: false,
      emojiPickerObserver: null,
      modalContent: {
        postId: null,
        postTitle: "Carregando...",
        post_html: "",
        reactions: { counts: {}, user_reaction: null },
        comments: [],
      },
      reactionTypes: [
        { type: "heart", icon: "bi-heart-fill" },
        { type: "lightbulb", icon: "bi-lightbulb-fill" },
        { type: "rocket", icon: "bi-rocket-takeoff-fill" },
        { type: "grin", icon: "bi-emoji-grin-fill" },
        { type: "hearteyes", icon: "bi-emoji-heart-eyes-fill" },
        { type: "surprise", icon: "bi-emoji-surprise-fill" },
      ],
      lastTrigger: null,
      socket: null,

      // HELPERS
      guessPlaceholderClass(html) {
        const h = (html || "").toLowerCase();
        if (h.includes("instagram.com")) return "aspect-square";
        if (h.includes("youtube.com") || h.includes("youtu.be"))
          return "aspect-video";
        if (
          h.includes("docs.google.com") ||
          h.includes("drive.google.com") ||
          h.includes("linkedin.com")
        )
          return "aspect-document";
        return "aspect-og";
      },

      async waitForEmbeds(container, timeoutMs = 2500) {
        if (!container) return;

        const collect = () => {
          const iframes = Array.from(container.querySelectorAll("iframe"));
          const imgs = Array.from(container.querySelectorAll("img"));
          return { iframes, imgs };
        };

        const onceLoad = (el) =>
          new Promise((res) => {
            if (el.tagName === "IMG" && el.complete) return res();
            el.addEventListener("load", () => res(), { once: true });
            setTimeout(() => res(), 1200); // fallback
          });

        // Instagram que usa <blockquote>
        try {
          if (
            window.instgrm &&
            container.querySelector("blockquote.instagram-media")
          ) {
            window.instgrm.Embeds.process();
          }
        } catch (_) {}

        await new Promise((r) => requestAnimationFrame(r));
        let { iframes, imgs } = collect();

        // Se ainda não veio o iframe do Instagram, observa rapidinho
        if (
          iframes.length === 0 &&
          container.querySelector("blockquote.instagram-media")
        ) {
          await new Promise((res) => {
            const obs = new MutationObserver(() => {
              const found = container.querySelector("iframe");
              if (found) {
                obs.disconnect();
                res();
              }
            });
            obs.observe(container, { childList: true, subtree: true });
            setTimeout(() => {
              obs.disconnect();
              res();
            }, 1200);
          });
          ({ iframes, imgs } = collect());
        }

        const mediaPromises = [...iframes.map(onceLoad), ...imgs.map(onceLoad)];

        if (mediaPromises.length === 0) {
          await new Promise((r) => setTimeout(r, 200));
          return;
        }

        await Promise.race([
          Promise.all(mediaPromises),
          new Promise((r) => setTimeout(r, timeoutMs)),
        ]);
      },

      normalizeEmbeds(container) {
        if (!container) return;

        // largura total e centralização
        container.querySelectorAll("iframe").forEach((f) => {
          f.removeAttribute("width");
          f.style.width = "100%";
          f.style.maxWidth = "100%";
          f.style.display = "block";
          f.style.margin = "0 auto";
          f.setAttribute("loading", f.getAttribute("loading") || "lazy");
        });

        container.querySelectorAll("img").forEach((img) => {
          img.style.maxWidth = "100%";
          img.style.height = "auto";
          img.style.display = "block";
          img.style.margin = "0 auto";
        });

        container
          .querySelectorAll("blockquote.instagram-media")
          .forEach((bq) => {
            bq.style.margin = "0 auto";
            bq.style.maxWidth = "100%";
            try {
              window.instgrm && window.instgrm.Embeds.process();
            } catch (_) {}
          });

        // Wrap 16:9 para players de vídeo
        container.querySelectorAll("iframe").forEach((f) => {
          const src = (f.getAttribute("src") || "").toLowerCase();
          const isVideo =
            src.includes("youtube.com") ||
            src.includes("youtu.be") ||
            src.includes("player.vimeo.com");
          if (
            isVideo &&
            !f.parentElement.classList.contains("nl-embed-video")
          ) {
            const wrap = document.createElement("div");
            wrap.className = "nl-embed-video";
            f.parentElement.insertBefore(wrap, f);
            wrap.appendChild(f);
          }
        });
      },

      copySourceLink() {
        if (!this.sourceLink) return;
        navigator.clipboard.writeText(this.sourceLink);
      },

      customizeEmojiPicker() {
        const picker = this.$refs.emojiPicker;
        if (!picker) return;

        // Tenta setar locale (só muda textos/labels; a busca do componente é em inglês)
        try { picker.locale = 'pt'; picker.setAttribute('locale','pt'); } catch {}

        const root = picker.shadowRoot;
        if (!root) {
          // algumas versões expõem evento de pronto; tenta de novo
          picker.addEventListener('ready', () => this.customizeEmojiPicker(), { once:true });
          return;
        }

        // CSS dentro do Shadow para esconder a busca em QUALQUER marcação
        const styleId = 'nl-emoji-shadow-style';
        let style = root.getElementById(styleId);
        if (!style) {
          style = document.createElement('style');
          style.id = styleId;
          style.textContent = `
      /* esconde a barra de busca e qualquer input de busca */
      [part="search"],
      [part="search-row"],
      [part="search-input"],
      header:has(input),
      .search-row,
      .search,
      input[type="search"] {
        display: none !important;
        height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: 0 !important;
      }
    `;
          root.appendChild(style);
        }

        // Remove programaticamente (caso o CSS aplique 1 frame depois)
        const hideSearch = () => {
          root.querySelectorAll(
            '[part="search"],[part="search-row"],[part="search-input"],header,.search-row,.search,input[type="search"]'
          ).forEach(el => {
            // se for o input, tenta esconder o contêiner mais próximo
            if (el.matches('input[type="search"]')) {
              const row = el.closest('[part="search-row"], .search-row, header, div, section');
              if (row) row.style.display = 'none';
            } else {
              el.style.display = 'none';
            }
          });
        };
        hideSearch();

        // Observa re-render do web component e reaplica
        if (!this.emojiPickerObserver) {
          this.emojiPickerObserver = new MutationObserver(() => hideSearch());
        }
        this.emojiPickerObserver.disconnect();
        this.emojiPickerObserver.observe(root, { childList: true, subtree: true });
      },

      onEmojiClick(e){
        const emoji = e.detail?.unicode || "";
        if(!emoji) return;
        const el = this.$refs.commentInput;
        this.insertAtCursor(el, emoji);
        this.autosizeTextarea(el);
        // NÃO fecha aqui. Fica aberto para escolher mais emojis.
      },

      insertAtCursor(el, text){
        if(!el) return;
        const start = el.selectionStart ?? el.value.length;
        const end   = el.selectionEnd   ?? el.value.length;
        const before = el.value.slice(0, start);
        const after  = el.value.slice(end);
        const next   = before + text + after;
        el.value = next;
        this.newCommentText = next;              // mantém Alpine em sincronia
        const pos = start + text.length;
        requestAnimationFrame(()=>{ el.setSelectionRange(pos, pos); el.focus(); });
      },

      onBodyScroll(e) {
        const el = e?.target || this.$refs.modalBody;
        if (!el) return;
        const max = el.scrollHeight - el.clientHeight;
        this.scrollPct = max > 0 ? Math.round((el.scrollTop / max) * 100) : 0;
        this.atTop = el.scrollTop <= 2;
        this.atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 2;
      },

      scrollToTop() {
        this.$refs.modalBody?.scrollTo({ top: 0, behavior: "smooth" });
      },

      setSourceLink() {
        try {
          const cnt = this.$refs.embedContent || this.$refs.modalBody;
          const a = cnt?.querySelector('a[href^="http"]');
          this.sourceLink = a ? a.href : "";
        } catch {
          this.sourceLink = "";
        }
      },

      // LIFECYCLE / SOCKET
      init() {
        this.socket = io();
        this.socket.on("connect", () => console.log("Socket.IO Conectado!"));

        this.socket.on("update_reactions", (data) => {
          const reactionCountEl = document.getElementById(
            `reactions-count-${data.post_id}`
          );
          if (reactionCountEl) {
            const total = Object.values(data.counts).reduce((a, b) => a + b, 0);
            reactionCountEl.innerText = ` ${total}`;
          }
          if (this.isModalOpen && this.modalContent.postId === data.post_id) {
            this.modalContent.reactions.counts = data.counts;
          }
        });

        this.socket.on("new_comment", (data) => {
          const postId = data.comment.post_id;
          const commentCountEl = document.getElementById(
            `comments-count-${postId}`
          );
          if (commentCountEl) {
            const current = parseInt(commentCountEl.innerText.trim()) || 0;
            commentCountEl.innerText = ` ${current + 1}`;
          }
          if (this.isModalOpen && this.modalContent.postId === postId) {
            if (
              !this.modalContent.comments.some((c) => c.id === data.comment.id)
            ) {
              this.modalContent.comments = [
                ...this.modalContent.comments,
                data.comment,
              ];
              this.$nextTick(() => {
                this.$refs.modalBody &&
                  (this.$refs.modalBody.scrollTop =
                    this.$refs.modalBody.scrollHeight);
              });
            }
          }
        });
      },

      // OPEN/CLOSE
      openModal(event, postId) {
        this.lastTrigger = event.currentTarget;
        document.body.style.overflow = "hidden";
        this.isModalOpen = true;
        this.isLoading = true;

        fetch(`/api/news/post_details?post_id=${postId}`)
          .then((res) => res.json())
          .then(async (data) => {
            if (!data.success) {
              this.modalContent.postTitle = "Erro";
              this.modalContent.post_html = `<p class="text-danger text-center">${data.error}</p>`;
              this.isLoading = false;
              return;
            }

            this.modalContent = data;
            this.placeholderClass = this.guessPlaceholderClass(
              this.modalContent.post_html
            );

            await this.$nextTick();
            this.normalizeEmbeds(
              this.$refs.embedContent || this.$refs.modalBody
            );
            try {
              this.onBodyScroll({ target: this.$refs.modalBody });
              this.setSourceLink();
              await this.waitForEmbeds(this.$refs.embedContent, 2500);
            } finally {
              this.isLoading = false;
              // Instagram reprocess
              try {
                window.instgrm && window.instgrm.Embeds.process();
              } catch (_) {}
            }
          });
      },

      closeModal() {
        this.isModalOpen = false;
        document.body.style.overflow = "";
        this.lastTrigger && this.lastTrigger.focus();
        this.modalContent = {
          postId: null,
          postTitle: "Carregando...",
          post_html: "",
          reactions: { counts: {}, user_reaction: null },
          comments: [],
        };
        this.sourceLink = "";
        this.scrollPct = 0;
        this.atTop = true;
        this.atBottom = false;
      },

      async openEnqueteModal(event, enqueteId) {
        this.lastTrigger = event.currentTarget;
        this.isLoading = true;
        this.isModalOpen = true;
        document.body.style.overflow = "hidden";

        this.modalContent.reactions = { counts: {}, user_reaction: null };
        this.modalContent.comments = [];

        const response = await fetch(`/newsletter/enquete/${enqueteId}`);
        if (response.ok) {
          const html = await response.text();
          this.modalContent.postTitle = "Enquete";
          this.modalContent.post_html = html;
        } else {
          this.modalContent.postTitle = "Erro";
          this.modalContent.post_html = `<p class="text-center text-danger">Não foi possível carregar a enquete.</p>`;
        }
        this.isLoading = false;
      },

      // REACTIONS / COMMENTS
      async toggleReaction(type) {
        const postId = this.modalContent.postId;
        const current = this.modalContent.reactions.user_reaction;

        if (current === type) {
          this.modalContent.reactions.user_reaction = null;
          this.modalContent.reactions.counts[type]--;
        } else {
          if (current) this.modalContent.reactions.counts[current]--;
          this.modalContent.reactions.user_reaction = type;
          this.modalContent.reactions.counts[type] =
            (this.modalContent.reactions.counts[type] || 0) + 1;
        }

        await fetch(`/api/news/post/${postId}/reacao`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tipo: type }),
        });
      },

      handleCommentSubmit(e) {
        if (!e.shiftKey) this.submitComment();
      },

      autosizeTextarea(el) {
        el.style.height = "auto";
        el.style.height = el.scrollHeight + "px";
      },

      async submitComment() {
        const text = this.newCommentText.trim();
        if (!text || this.isSubmitting) return;

        this.isSubmitting = true;
        try {
          const response = await fetch(
            `/api/news/post/${this.modalContent.postId}/comentarios`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ texto: text }),
            }
          );

          if (response.ok) {
            this.newCommentText = "";
            this.showEmojiPicker = false;   // fecha somente ao enviar
            this.$nextTick(() => {
              const input = this.$refs.commentInput;
              if (input) this.autosizeTextarea(input);
            });
          } else {
            alert("Erro ao enviar comentário.");
          }
        } finally {
          this.isSubmitting = false;
        }
      },
    };
  }
</script>
{% endblock %}
