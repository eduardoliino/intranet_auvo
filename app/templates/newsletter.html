{% extends 'base.html' %} {% block content %}
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='css/newsletter.css') }}"
/>
<style>
  .nl-reaction-chip.selected {
    background-color: #e8e3ff; /* Um tom de roxo bem claro (lilás) */
    border-color: #a891f2;   /* Borda em um tom de roxo mais forte */
    color: #6c47d8;          /* Cor do ícone e do contador */
  }
  .nl-reaction-chip.selected .nl-count {
    color: #6c47d8; /* Garante que o contador também mude de cor */
  }
</style>

<div class="nl-feed py-4" x-data="newsletterFeed()">
  <h1 class="mb-4">Auvo News</h1>

  <input 
      type="search" 
      class="form-control form-control-lg mb-5" 
      placeholder="Pesquisar"
      x-model="searchTerm"
      @input.debounce.500ms="performSearch()"
      aria-label="Pesquisar no feed">

  {% if fixados_posts or fixados_enquetes %}
  <h4 class="mb-3 text-muted">Destaques</h4>
  <div class="row g-5 mb-5">
    {% for post in fixados_posts %}
    <div class="col-md-6">{% include 'partials/news_post_card.html' %}</div>
    {% endfor %} {% for enquete in fixados_enquetes %}
    <div class="col-md-6">{% include 'partials/news_enquete_card.html' %}</div>
    {% endfor %}
  </div>
  {% endif %}


  <div class="row g-5">
    <template x-for="item in feed" :key="item.type + '-' + item.id">
        <div class="col-md-6" 
             x-transition:enter="transition ease-out duration-300"
             x-transition:enter-start="opacity-0 transform -translate-y-4"
             x-transition:enter-end="opacity-100 transform translate-y-0">
            <template x-if="item.type === 'post'">
                <article class="nl-card nl-card-post h-100" @click="openModal($event, item.id)" style="cursor: pointer;" tabindex="0" @keydown.enter.prevent="openModal($event, item.id)">
                    <header class="nl-hd">
                        <template x-if="item.autor_foto">
                            <img :src="item.autor_foto" class="nl-avatar" :alt="'Foto de ' + item.autor_nome" />
                        </template>
                        <template x-if="!item.autor_foto">
                            <div class="nl-avatar d-flex justify-content-center align-items-center bg-secondary text-white">
                                <span x-text="item.autor_iniciais"></span>
                            </div>
                        </template>
                        <div>
                            <h5 x-text="item.autor_nome"></h5>
                            <div class="nl-meta" x-text="item.publicado_em"></div>
                        </div>
                    </header>
                    <div class="nl-body">
                        <h5 x-text="item.titulo"></h5>
                    </div>
                    <footer class="nl-ft">
                        <div class="d-flex justify-content-between align-items-center w-100">
                            <div class="text-muted small">
                                <i class="bi bi-hand-thumbs-up-fill nl-counter-icon"></i> <span x-text="item.total_reacoes"></span>
                                <i class="bi bi-chat-text nl-counter-icon ms-3"></i> <span x-text="item.total_comentarios"></span>
                            </div>
                        </div>
                    </footer>
                </article>
            </template>
            <template x-if="item.type === 'enquete'">
                <article class="nl-card nl-card-enquete h-100" @click="openEnqueteModal($event, item.id)" style="cursor: pointer;" tabindex="0" @keydown.enter.prevent="openEnqueteModal($event, item.id)">
                    <div class="nl-body py-4">
                        <h5 x-text="item.pergunta"></h5>
                        <p class="nl-meta" x-text="item.status"></p>
                        <template x-for="(opcao, index) in item.opcoes" :key="index">
                           <div class="nl-poll-option" x-text="opcao.texto"></div>
                        </template>
                    </div>
                </article>
            </template>
        </div>
    </template>
  </div>

  <div x-show="hasMore && !isLoadingFeed" class="text-center mt-5">
      <button class="btn btn-auvo btn-lg" @click="fetchFeed()">
          <i class="bi bi-arrow-clockwise"></i> Carregar Mais
      </button>
  </div>

  <div x-show="isLoadingFeed" class="text-center mt-5">
      <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
          <span class="visually-hidden">Carregando...</span>
      </div>
  </div>
  
  <div x-show="!isLoadingFeed && feed.length === 0 && searchTerm" class="text-center text-muted mt-5">
      <p>Nenhum resultado encontrado para a sua busca.</p>
  </div>
  
  <div x-show="!isLoadingFeed && feed.length === 0 && !searchTerm" class="text-center text-muted mt-5">
      <p>Nenhuma publicação no feed ainda.</p>
  </div>

  <div
    x-show="isModalOpen"
    x-transition:enter="transition ease-out duration-200"
    x-transition:enter-start="opacity-0"
    x-transition:enter-end="opacity-100"
    x-transition:leave="transition ease-in duration-150"
    x-transition:leave-start="opacity-100"
    x-transition:leave-end="opacity-0"
    class="nl-modal-overlay"
    @click.self="closeModal()"
    @keydown.escape.window="closeModal()"
    x-cloak
  >
    <div
      x-show="isModalOpen"
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 scale-95"
      x-transition:enter-end="opacity-100 scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 scale-100"
      x-transition:leave-end="opacity-0 scale-95"
      class="nl-modal-dialog"
      role="dialog"
      aria-modal="true"
      :aria-labelledby="'modal-title-' + modalContent.postId"
    >
      <header class="nl-modal-header">
        <h5
          class="nl-modal-title"
          x-text="modalContent.postTitle || 'Detalhes'"
        ></h5>
        <div class="nl-modal-actions">
          <a
            x-show="sourceLink"
            :href="sourceLink"
            target="_blank"
            rel="noopener"
            class="nl-link-out"
            >Abrir link</a
          >
          <button
            x-show="sourceLink"
            type="button"
            class="nl-btn-icon"
            @click="copySourceLink()"
            aria-label="Copiar link"
          >
            <i class="bi bi-link-45deg" aria-hidden="true"></i>
          </button>
          <button
            type="button"
            class="nl-btn-icon"
            @click="closeModal"
            aria-label="Fechar"
          >
            <i class="bi bi-x-lg" aria-hidden="true"></i>
          </button>
        </div>

        <div class="nl-progress">
          <span :style="{ width: scrollPct + '%' }"></span>
        </div>
      </header>

      <div
        class="nl-modal-body nl-scrollfade custom-scrollbar"
        x-ref="modalBody"
        :class="{'has-top-shadow': !atTop, 'has-bottom-shadow': !atBottom}"
        @scroll.debounce.100ms="onBodyScroll($event)"
        :aria-busy="isLoading"
      >
        <div
          x-show="isLoading"
          :class="'embed-placeholder ' + (placeholderClass || 'aspect-video')"
        ></div>

        <div x-show="!isLoading" class="w-100">
          <div
            x-ref="embedContent"
            class="nl-embed-wrap"
            x-html="modalContent.post_html"
          ></div>

          <hr class="my-4" />

          <div class="d-flex align-items-center gap-2 flex-wrap mb-3">
            <template
              x-for="reactionType in reactionTypes"
              :key="reactionType.type"
            >
              <button
                :class="['nl-reaction-chip', { 'selected': modalContent.reactions.user_reaction === reactionType.type, 'zero-count': !(modalContent.reactions.counts[reactionType.type] > 0) }]"
                :style="modalContent.reactions.user_reaction === reactionType.type ? 'background-color: var(--cor-primaria-muito-clara); border-color: var(--cor-primaria); color: var(--cor-primaria-escura);' : ''"
                :aria-pressed="(modalContent.reactions.user_reaction === reactionType.type).toString()"
                @click.stop.prevent="toggleReaction(reactionType.type)"
              >
                <i class="bi" :class="reactionType.icon"></i>
                <span
                  class="nl-count"
                  x-text="modalContent.reactions.counts[reactionType.type] || 0"
                ></span>
              </button>
            </template>
          </div>

          <h6>Comentários</h6>
          <div class="mb-4">
            <template x-for="comment in modalContent.comments" :key="comment.id">
              <div class="d-flex align-items-start my-3 nl-comment-item" @mouseenter="comment.showDelete = true" @mouseleave="comment.showDelete = false">
                <template x-if="comment.user_photo">
                  <img :src="comment.user_photo" class="nl-avatar me-3" :alt="'Foto de ' + comment.user_name" />
                </template>
                <template x-if="!comment.user_photo">
                  <div class="nl-avatar d-flex justify-content-center align-items-center bg-secondary text-white me-3 flex-shrink-0">
                    <span x-text="comment.user_initials"></span>
                  </div>
                </template>
                <div class="w-100 position-relative">
                  <strong x-text="comment.user_name"></strong>
                  <p class="mb-0" style="white-space: pre-wrap; word-break: break-word" x-text="comment.text"></p>
            
                  <button
                      x-show="comment.showDelete && (modalContent.current_user.id === comment.user_id || modalContent.current_user.is_admin)"
                      @click.stop="confirmDeleteComment(comment.id)"
                      class="btn btn-sm btn-outline-danger nl-comment-delete-btn"
                      aria-label="Remover comentário"
                      x-cloak>
                      <i class="bi bi-trash"></i>
                  </button>
                </div>
              </div>
            </template>
          </div>
        </div>
      </div>

      <footer class="nl-modal-footer">
        <form class="nl-comment-bar" @submit.prevent="submitComment()">
          <div class="nl-comment-field">
            <button
              type="button"
              class="nl-emoji-btn"
              @click="showEmojiPicker = !showEmojiPicker; if(showEmojiPicker){ $nextTick(()=> customizeEmojiPicker()) }"
              :aria-expanded="showEmojiPicker ? 'true' : 'false'"
              aria-label="Inserir emoji"
            >
              <i class="bi bi-emoji-smile"></i>
            </button>

            <textarea
              x-model="newCommentText"
              x-ref="commentInput"
              rows="1"
              class="nl-comment-input"
              placeholder="Adicionar um comentário..."
              @keydown.enter.prevent.stop="handleCommentSubmit($event)"
              @input="autosizeTextarea($event.target)"
              aria-label="Adicionar um comentário"
            ></textarea>

            <button
              type="submit"
              class="nl-comment-send"
              :disabled="isSubmitting || !newCommentText.trim()"
              aria-label="Enviar comentário"
            >
              <i class="bi bi-send-fill" aria-hidden="true"></i>
            </button>

            <div
              class="nl-emoji-popover"
              x-show="showEmojiPicker"
              x-transition
              @click.outside="showEmojiPicker=false"
              x-init="$nextTick(()=> customizeEmojiPicker())"
            >
              <emoji-picker
                x-ref="emojiPicker"
                @emoji-click="onEmojiClick"
              ></emoji-picker>
            </div>
          </div>
        </form>
      </footer>

      <div class="nl-new-comment-toast-wrapper" x-show="showNewCommentButton" x-transition x-cloak>
          <button type="button" class="nl-new-comment-toast" @click="scrollToBottom()">
              <i class="bi bi-arrow-down-circle-fill"></i>
              <span x-text="newCommentCount > 1 ? `${newCommentCount} novos comentários` : 'Novo comentário'"></span>
          </button>
      </div>
    </div>
  </div>

<div class="modal fade" id="confirmDeleteCommentModal" tabindex="-1" aria-hidden="true" style="z-index: 2050;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Remover Comentário</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
      </div>
      <div class="modal-body">
        <p>Tem certeza de que deseja remover este comentário?</p>
        <p class="text-danger small mt-2">Esta ação é permanente.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-danger" @click="deleteComment()">Remover</button>
      </div>
    </div>
  </div>
</div>
</div>
{% endblock %}

{% block page_scripts %}
<script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
  function newsletterFeed() {
    return {
      isModalOpen: false,
      isLoading: true,
      newCommentText: "",
      isSubmitting: false,
      sourceLink: "",
      scrollPct: 0,
      atTop: true,
      atBottom: false,
      placeholderClass: "aspect-video",
      showEmojiPicker: false,
      emojiPickerStyled: false,
      emojiPickerObserver: null,
      showNewCommentButton: false,
      newCommentCount: 0,
      commentToDeleteId: null,
      deleteModal: null,
      modalContent: {
        postId: null,
        postTitle: "Carregando...",
        post_html: "",
        reactions: { counts: {}, user_reaction: null },
        comments: [],
        current_user: { id: null, is_admin: false },
      },
      reactionTypes: [
        { type: "heart", icon: "bi-heart-fill" },
        { type: "lightbulb", icon: "bi-lightbulb-fill" },
        { type: "rocket", icon: "bi-rocket-takeoff-fill" },
        { type: "grin", icon: "bi-emoji-grin-fill" },
        { type: "hearteyes", icon: "bi-emoji-heart-eyes-fill" },
        { type: "surprise", icon: "bi-emoji-surprise-fill" },
      ],
      lastTrigger: null,
      socket: null,

      feed: [],
      isLoadingFeed: false,
      currentPage: 1,
      hasMore: true,
      searchTerm: '',

      guessPlaceholderClass(html) {
        const h = (html || "").toLowerCase();
        if (h.includes("instagram.com")) return "aspect-square";
        if (h.includes("youtube.com") || h.includes("youtu.be"))
          return "aspect-video";
        if (
          h.includes("docs.google.com") ||
          h.includes("drive.google.com") ||
          h.includes("linkedin.com")
        )
          return "aspect-document";
        return "aspect-og";
      },

      async waitForEmbeds(container, timeoutMs = 2500) {
        if (!container) return;

        const collect = () => {
          const iframes = Array.from(container.querySelectorAll("iframe"));
          const imgs = Array.from(container.querySelectorAll("img"));
          return { iframes, imgs };
        };

        const onceLoad = (el) =>
          new Promise((res) => {
            if (el.tagName === "IMG" && el.complete) return res();
            el.addEventListener("load", () => res(), { once: true });
            setTimeout(() => res(), 1200); // fallback
          });
        try {
          if (
            window.instgrm &&
            container.querySelector("blockquote.instagram-media")
          ) {
            window.instgrm.Embeds.process();
          }
        } catch (_) {}

        await new Promise((r) => requestAnimationFrame(r));
        let { iframes, imgs } = collect();

        if (
          iframes.length === 0 &&
          container.querySelector("blockquote.instagram-media")
        ) {
          await new Promise((res) => {
            const obs = new MutationObserver(() => {
              const found = container.querySelector("iframe");
              if (found) {
                obs.disconnect();
                res();
              }
            });
            obs.observe(container, { childList: true, subtree: true });
            setTimeout(() => {
              obs.disconnect();
              res();
            }, 1200);
          });
          ({ iframes, imgs } = collect());
        }

        const mediaPromises = [...iframes.map(onceLoad), ...imgs.map(onceLoad)];

        if (mediaPromises.length === 0) {
          await new Promise((r) => setTimeout(r, 200));
          return;
        }

        await Promise.race([
          Promise.all(mediaPromises),
          new Promise((r) => setTimeout(r, timeoutMs)),
        ]);
      },

      normalizeEmbeds(container) {
        if (!container) return;

        container.querySelectorAll("iframe").forEach((f) => {
          f.removeAttribute("width");
          f.style.width = "100%";
          f.style.maxWidth = "100%";
          f.style.display = "block";
          f.style.margin = "0 auto";
          f.setAttribute("loading", f.getAttribute("loading") || "lazy");
        });

        container.querySelectorAll("img").forEach((img) => {
          img.style.maxWidth = "100%";
          img.style.height = "auto";
          img.style.display = "block";
          img.style.margin = "0 auto";
        });

        container
          .querySelectorAll("blockquote.instagram-media")
          .forEach((bq) => {
            bq.style.margin = "0 auto";
            bq.style.maxWidth = "100%";
            try {
              window.instgrm && window.instgrm.Embeds.process();
            } catch (_) {}
          });

        container.querySelectorAll("iframe").forEach((f) => {
          const src = (f.getAttribute("src") || "").toLowerCase();
          const isVideo =
            src.includes("youtube.com") ||
            src.includes("youtu.be") ||
            src.includes("player.vimeo.com");
          if (
            isVideo &&
            !f.parentElement.classList.contains("nl-embed-video")
          ) {
            const wrap = document.createElement("div");
            wrap.className = "nl-embed-video";
            f.parentElement.insertBefore(wrap, f);
            wrap.appendChild(f);
          }
        });
      },

      copySourceLink() {
        if (!this.sourceLink) return;
        navigator.clipboard.writeText(this.sourceLink);
      },

      customizeEmojiPicker() {
        const picker = this.$refs.emojiPicker;
        if (!picker) return;

        try { picker.locale = 'pt'; picker.setAttribute('locale','pt'); } catch {}

        const root = picker.shadowRoot;
        if (!root) {
          picker.addEventListener('ready', () => this.customizeEmojiPicker(), { once:true });
          return;
        }

        const styleId = 'nl-emoji-shadow-style';
        let style = root.getElementById(styleId);
        if (!style) {
          style = document.createElement('style');
          style.id = styleId;
          style.textContent = `
      [part="search"],
      [part="search-row"],
      [part="search-input"],
      header:has(input),
      .search-row,
      .search,
      input[type="search"] {
        display: none !important;
        height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: 0 !important;
      }
    `;
          root.appendChild(style);
        }

        const hideSearch = () => {
          root.querySelectorAll(
            '[part="search"],[part="search-row"],[part="search-input"],header,.search-row,.search,input[type="search"]'
          ).forEach(el => {
            if (el.matches('input[type="search"]')) {
              const row = el.closest('[part="search-row"], .search-row, header, div, section');
              if (row) row.style.display = 'none';
            } else {
              el.style.display = 'none';
            }
          });
        };
        hideSearch();

        if (!this.emojiPickerObserver) {
          this.emojiPickerObserver = new MutationObserver(() => hideSearch());
        }
        this.emojiPickerObserver.disconnect();
        this.emojiPickerObserver.observe(root, { childList: true, subtree: true });
      },

      onEmojiClick(e){
        const emoji = e.detail?.unicode || "";
        if(!emoji) return;
        const el = this.$refs.commentInput;
        this.insertAtCursor(el, emoji);
        this.autosizeTextarea(el);
      },

      insertAtCursor(el, text){
        if(!el) return;
        const start = el.selectionStart ?? el.value.length;
        const end   = el.selectionEnd   ?? el.value.length;
        const before = el.value.slice(0, start);
        const after  = el.value.slice(end);
        const next   = before + text + after;
        el.value = next;
        this.newCommentText = next;
        const pos = start + text.length;
        requestAnimationFrame(()=>{ el.setSelectionRange(pos, pos); el.focus(); });
      },

      onBodyScroll(e) {
        const el = e?.target || this.$refs.modalBody;
        if (!el) return;
        const max = el.scrollHeight - el.clientHeight;
        this.scrollPct = max > 0 ? Math.round((el.scrollTop / max) * 100) : 0;
        this.atTop = el.scrollTop <= 2;
        this.atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 2;

        if (this.atBottom) {
            this.showNewCommentButton = false;
            this.newCommentCount = 0;
        }
      },

      scrollToBottom() {
        this.$refs.modalBody?.scrollTo({ top: this.$refs.modalBody.scrollHeight, behavior: 'smooth' });
        this.showNewCommentButton = false;
        this.newCommentCount = 0;
      },

      setSourceLink() {
        try {
          const cnt = this.$refs.embedContent || this.$refs.modalBody;
          const a = cnt?.querySelector('a[href^="http"]');
          this.sourceLink = a ? a.href : "";
        } catch {
          this.sourceLink = "";
        }
      },

      handleReactionUpdate(data) {
          const item = this.feed.find(p => p.type === 'post' && p.id === data.post_id);
          if (item) {
              item.total_reacoes = Object.values(data.counts).reduce((a, b) => a + b, 0);
          }
          if (this.isModalOpen && this.modalContent.postId === data.post_id) {
              this.modalContent.reactions.counts = data.counts;
          }
      },

      handleNewComment(data) {
        const postId = data.comment.post_id;
        const item = this.feed.find(p => p.type === 'post' && p.id === postId);
        if (item) {
            item.total_comentarios++;
        }
        if (this.isModalOpen && this.modalContent.postId === postId) {
            if (!this.modalContent.comments.some((c) => c.id === data.comment.id)) {
                const el = this.$refs.modalBody;
                const isNearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 100; // Adiciona a propriedade ao novo comentário
                data.comment.showDelete = false;
                this.modalContent.comments.push(data.comment);
                this.$nextTick(() => {
                    if (isNearBottom) { this.scrollToBottom(); } 
                    else { this.showNewCommentButton = true; this.newCommentCount++; }
                });
            }
        }
      },

      handleCommentDeleted(data) {
        const { comment_id, post_id } = data;

        const feedItem = this.feed.find(p => p.type === 'post' && p.id === post_id);
        if (feedItem && feedItem.total_comentarios > 0) {
            feedItem.total_comentarios--;
        }

        if (this.isModalOpen && this.modalContent.postId === post_id) {
            const index = this.modalContent.comments.findIndex(c => c.id === comment_id);
            if (index > -1) {
                this.modalContent.comments.splice(index, 1);
            }
        }
      },

      async fetchFeed() {
        if (this.isLoadingFeed || !this.hasMore) return;
        this.isLoadingFeed = true;

        const url = `/api/news/feed?page=${this.currentPage}&search=${encodeURIComponent(this.searchTerm)}`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            
            if (this.currentPage === 1) {
                this.feed = data.feed;
            } else {
                this.feed.push(...data.feed);
            }

            this.hasMore = data.has_next;
            this.currentPage++;
        } catch (error) {
            console.error('Erro ao carregar o feed:', error);
        } finally {
            this.isLoadingFeed = false;
        }
      },

      performSearch() {
        this.currentPage = 1;
        this.hasMore = true;
        this.feed = [];
        this.fetchFeed();
      },

      init() {
        this.socket = io();
        this.socket.on("connect", () => console.log("Socket.IO Conectado!"));
        this.socket.on("update_reactions", (data) => this.handleReactionUpdate(data));
        this.socket.on("new_comment", (data) => this.handleNewComment(data));
        this.socket.on('comment_deleted', (data) => this.handleCommentDeleted(data));
        this.fetchFeed();

        this.deleteModal = new bootstrap.Modal(document.getElementById('confirmDeleteCommentModal'));
      },

      openModal(event, postId) {
        this.lastTrigger = event.currentTarget;
        document.body.style.overflow = "hidden";
        this.isModalOpen = true;
        this.isLoading = true;
        this.showNewCommentButton = false;
        this.newCommentCount = 0;

        fetch(`/api/news/post_details?post_id=${postId}`)
          .then((res) => res.json())
          .then(async (data) => {
            if (data.success) {
              data.comments.forEach(c => c.showDelete = false);
              this.modalContent = data;
              this.placeholderClass = this.guessPlaceholderClass(
                this.modalContent.post_html
              );

              await this.$nextTick();
              this.normalizeEmbeds(
                this.$refs.embedContent || this.$refs.modalBody
              );
              try {
                this.onBodyScroll();
                this.setSourceLink();
                await this.waitForEmbeds(this.$refs.embedContent, 2500);
              } finally {
                this.isLoading = false;
                try {
                  window.instgrm && window.instgrm.Embeds.process();
                } catch (_) {}
              }
            } else {
              this.modalContent.postTitle = "Erro";
              this.modalContent.post_html = `<p class="text-danger text-center">${data.error}</p>`;
              this.isLoading = false;
            }
          });
      },

      closeModal() {
        this.isModalOpen = false;
        document.body.style.overflow = "";
        this.lastTrigger?.focus();
        this.showNewCommentButton = false;
        this.newCommentCount = 0;
        this.modalContent = {
          postId: null,
          postTitle: "Carregando...",
          post_html: "",
          reactions: { counts: {}, user_reaction: null },
          comments: [],
        };
        this.sourceLink = "";
        this.scrollPct = 0;
        this.atTop = true;
        this.atBottom = false;
      },

      async openEnqueteModal(event, enqueteId) {
        this.lastTrigger = event.currentTarget;
        this.isLoading = true;
        this.isModalOpen = true;
        document.body.style.overflow = "hidden";
        this.showNewCommentButton = false;
        this.newCommentCount = 0;

        this.modalContent.reactions = { counts: {}, user_reaction: null };
        this.modalContent.comments = [];

        const response = await fetch(`/newsletter/enquete/${enqueteId}`);
        if (response.ok) {
          const html = await response.text();
          this.modalContent.postTitle = "Enquete";
          this.modalContent.post_html = html;
        } else {
          this.modalContent.postTitle = "Erro";
          this.modalContent.post_html = `<p class="text-center text-danger">Não foi possível carregar a enquete.</p>`;
        }
        this.isLoading = false;
      },

      async toggleReaction(type) {
        const postId = this.modalContent.postId;
        const current = this.modalContent.reactions.user_reaction;

        if (current === type) {
          this.modalContent.reactions.user_reaction = null;
          this.modalContent.reactions.counts[type]--;
        } else {
          if (current) this.modalContent.reactions.counts[current]--;
          this.modalContent.reactions.user_reaction = type;
          this.modalContent.reactions.counts[type] =
            (this.modalContent.reactions.counts[type] || 0) + 1;
        }

        await fetch(`/api/news/post/${postId}/reacao`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tipo: type }),
        });
      },

      handleCommentSubmit(e) {
        if (!e.shiftKey) this.submitComment();
      },

      autosizeTextarea(el) {
        el.style.height = "auto";
        el.style.height = el.scrollHeight + "px";
      },

      async submitComment() {
        const text = this.newCommentText.trim();
        if (!text || this.isSubmitting) return;

        this.isSubmitting = true;
        try {
          const response = await fetch(
            `/api/news/post/${this.modalContent.postId}/comentarios`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ texto: text }),
            }
          );

          if (response.ok) {
            this.newCommentText = "";
            this.showEmojiPicker = false;
            this.$nextTick(() => {
              const input = this.$refs.commentInput;
              if (input) this.autosizeTextarea(input);
            });
          } else {
            alert("Erro ao enviar comentário.");
          }
        } finally {
          this.isSubmitting = false;
        }
      },

      confirmDeleteComment(commentId) {
        this.commentToDeleteId = commentId;
        this.deleteModal.show();
      },

      async deleteComment() {
        if (!this.commentToDeleteId) return;
        const commentId = this.commentToDeleteId;
        try {
          const response = await fetch(`/api/news/comment/${commentId}`, {
            method: 'DELETE'
          });
          if (!response.ok) {
            alert('Erro ao remover o comentário.');
          }
        } finally {
          this.deleteModal.hide();
          this.commentToDeleteId = null;
        }
      },
    };
  }
</script>
{% endblock %}